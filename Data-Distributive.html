<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Distributive</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Distributive.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-Distributive.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributive-0.4.2: Distributive functors -- Dual to Traversable</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(C) 2011-2014 Edward Kmett</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>Edward Kmett &lt;ekmett@gmail.com&gt;</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Distributive</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> Functor g =&gt; <a href="#t:Distributive">Distributive</a> g <span class="keyword">where</span><ul class="subs"><li><a href="#v:distribute">distribute</a> :: Functor f =&gt; f (g a) -&gt; g (f a)</li><li><a href="#v:collect">collect</a> :: Functor f =&gt; (a -&gt; g b) -&gt; f a -&gt; g (f b)</li><li><a href="#v:distributeM">distributeM</a> :: Monad m =&gt; m (g a) -&gt; g (m a)</li><li><a href="#v:collectM">collectM</a> :: Monad m =&gt; (a -&gt; g b) -&gt; m a -&gt; g (m b)</li></ul></li><li class="src short"><a href="#v:cotraverse">cotraverse</a> :: (Functor f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (f a -&gt; b) -&gt; f (g a) -&gt; g b</li><li class="src short"><a href="#v:comapM">comapM</a> :: (Monad m, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (m a -&gt; b) -&gt; m (g a) -&gt; g b</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> Functor g =&gt; <a name="t:Distributive" class="def">Distributive</a> g <span class="keyword">where</span> <a href="src/Data-Distributive.html#Distributive" class="link">Source</a></p><div class="doc"><p>This is the categorical dual of <code>Traversable</code>.</p><p>Due to the lack of non-trivial comonoids in Haskell, we can restrict
 ourselves to requiring a <code>Functor</code> rather than
 some Coapplicative class. Categorically every <code><a href="Data-Distributive.html#t:Distributive">Distributive</a></code>
 functor is actually a right adjoint, and so it must be <code>Representable</code>
 endofunctor and preserve all limits. This is a fancy way of saying it
 isomorphic to `(-&gt;) x` for some x.</p><p>Minimal complete definition: <code><a href="Data-Distributive.html#v:distribute">distribute</a></code> or <code><a href="Data-Distributive.html#v:collect">collect</a></code></p><p>To be distributable a container will need to have a way to consistently
 zip a potentially infinite number of copies of itself. This effectively
 means that the holes in all values of that type, must have the same
 cardinality, fixed sized vectors, infinite streams, functions, etc.
 and no extra information to try to merge together.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:distribute" class="def">distribute</a> :: Functor f =&gt; f (g a) -&gt; g (f a) <a href="src/Data-Distributive.html#distribute" class="link">Source</a></p><div class="doc"><p>The dual of <code><a href="Data-Traversable.html#v:sequenceA">sequenceA</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>distribute [(+1),(+2)] 1
</code></strong>[2,3]
</pre><pre><code><a href="Data-Distributive.html#v:distribute">distribute</a></code> = <code><a href="Data-Distributive.html#v:collect">collect</a></code> <code>id</code></pre></div><p class="src"><a name="v:collect" class="def">collect</a> :: Functor f =&gt; (a -&gt; g b) -&gt; f a -&gt; g (f b) <a href="src/Data-Distributive.html#collect" class="link">Source</a></p><div class="doc"><pre><code><a href="Data-Distributive.html#v:collect">collect</a></code> f = <code><a href="Data-Distributive.html#v:distribute">distribute</a></code> . <code>fmap</code> f</pre></div><p class="src"><a name="v:distributeM" class="def">distributeM</a> :: Monad m =&gt; m (g a) -&gt; g (m a) <a href="src/Data-Distributive.html#distributeM" class="link">Source</a></p><div class="doc"><p>The dual of <code><a href="Data-Traversable.html#v:sequence">sequence</a></code></p><pre><code><a href="Data-Distributive.html#v:distributeM">distributeM</a></code> = <code>fmap</code> <code>unwrapMonad</code> . <code><a href="Data-Distributive.html#v:distribute">distribute</a></code> . <code>WrapMonad</code></pre></div><p class="src"><a name="v:collectM" class="def">collectM</a> :: Monad m =&gt; (a -&gt; g b) -&gt; m a -&gt; g (m b) <a href="src/Data-Distributive.html#collectM" class="link">Source</a></p><div class="doc"><pre><code><a href="Data-Distributive.html#v:collectM">collectM</a></code> = <code><a href="Data-Distributive.html#v:distributeM">distributeM</a></code> . <code>liftM</code> f</pre></div></div><div class="subs instances"><p id="control.i:Distributive" class="caption collapser" onclick="toggleSection('i:Distributive')">Instances</p><div id="section.i:Distributive" class="show"><table><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> Identity</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> ((-&gt;) e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> (Proxy *)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> f =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (Backwards f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> g =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (IdentityT g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> f =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (Reverse f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> g =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (ReaderT e g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Distributive.html#t:Distributive">Distributive</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (Compose f g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Distributive.html#t:Distributive">Distributive</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (Product f g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> (Tagged * t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:cotraverse" class="def">cotraverse</a> :: (Functor f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (f a -&gt; b) -&gt; f (g a) -&gt; g b <a href="src/Data-Distributive.html#cotraverse" class="link">Source</a></p><div class="doc"><p>The dual of <code><a href="Data-Traversable.html#v:traverse">traverse</a></code></p><pre><code><a href="Data-Distributive.html#v:cotraverse">cotraverse</a></code> f = <code>fmap</code> f . <code><a href="Data-Distributive.html#v:distribute">distribute</a></code></pre></div></div><div class="top"><p class="src"><a name="v:comapM" class="def">comapM</a> :: (Monad m, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (m a -&gt; b) -&gt; m (g a) -&gt; g b <a href="src/Data-Distributive.html#comapM" class="link">Source</a></p><div class="doc"><p>The dual of <code><a href="Data-Traversable.html#v:mapM">mapM</a></code></p><pre><code><a href="Data-Distributive.html#v:comapM">comapM</a></code> f = <code>fmap</code> f . <code><a href="Data-Distributive.html#v:distributeM">distributeM</a></code></pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.1</p></div></body></html>